[{"author":null,"categories":["Tech"],"content":"用go语言实现一个containerd-shim，支持在k8s中调度wasm程序。通过为shim添加dapr 组件的host abi支持，使被调度的wasm程序可以获得访问dapr组件的能力。","date":1693829180,"description":"用go语言实现一个containerd-shim，支持在k8s中调度wasm程序。通过为shim添加dapr 组件的host abi支持，使被调度的wasm程序可以获得访问dapr组件的能力。","dir":"post/","excerpt_html":"用go语言实现一个containerd-shim，支持在k8s中调度wasm程序。通过为shim添加dapr 组件的host abi支持，使被调度的wasm程序可以获得访问dapr组件的能力。","excerpt_text":"用go语言实现一个containerd-shim，支持在k8s中调度wasm程序。通过为shim添加dapr 组件的host abi支持，使被调度的wasm程序可以获得访问dapr组件的能力。","expirydate":-62135596800,"fuzzywordcount":2200,"html":"用go语言实现一个containerd-shim，支持在k8s中调度wasm程序。通过为shim添加dapr 组件的host abi支持，使被调度的wasm程序可以获得访问dapr组件的能力。","keywords":null,"kind":"page","lang":"en","lastmod":1693829180,"objectID":"74c76b142113736bf03ae040656768eb","permalink":"https://taction.top/post/run-dapr-wasm-in-k8s/","publishdate":"2023-09-04T20:06:20+08:00","readingtime":5,"relpermalink":"/post/run-dapr-wasm-in-k8s/","section":"post","summary":"用go语言实现一个containerd-shim，支持在k8s中调度wasm程序。通过为shim添加dapr 组件的host abi支持，使被调","tags":["containerd","shim","webassembly","k8s"],"title":"在K8s中调度Dapr Wasm程序","type":"post","url":"/post/run-dapr-wasm-in-k8s/","weight":0,"wordcount":2161},{"author":null,"categories":["Tech"],"content":"在K8s中运行Wasm container","date":1693732076,"description":"在K8s中运行Wasm container","dir":"post/","excerpt_html":"在K8s中运行Wasm container","excerpt_text":"在K8s中运行Wasm container","expirydate":-62135596800,"fuzzywordcount":500,"html":"在K8s中运行Wasm container","keywords":null,"kind":"page","lang":"en","lastmod":1693732076,"objectID":"2a6449e55656bc05aa41fb37a7911e2c","permalink":"https://taction.top/post/run-wasm-in-k8s/","publishdate":"2023-09-03T17:07:56+08:00","readingtime":1,"relpermalink":"/post/run-wasm-in-k8s/","section":"post","summary":"本文介绍一种通过containerd shim支持在k8s中运行wasm的方法 先决条件 Intall k3d wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash kubectl curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl chmod +x ./kubectl sudo mv ./kubectl /usr/local/bin/kubectl 启动k3d 在","tags":["WebAssembly","dapr","containerd-shim","k8s"],"title":"在K8s中运行Wasm container","type":"post","url":"/post/run-wasm-in-k8s/","weight":0,"wordcount":431},{"author":null,"categories":["Tech"],"content":"本文以实际案例介绍如何借助WebAssembly组件模型来自定义Wasm及开发对应的go语言SDK。","date":1693570279,"description":"本文以实际案例介绍如何借助WebAssembly组件模型来自定义Wasm及开发对应的go语言SDK。","dir":"post/","excerpt_html":"本文以实际案例介绍如何借助WebAssembly组件模型来自定义Wasm及开发对应的go语言SDK。","excerpt_text":"本文以实际案例介绍如何借助WebAssembly组件模型来自定义Wasm及开发对应的go语言SDK。","expirydate":-62135596800,"fuzzywordcount":4300,"html":"本文以实际案例介绍如何借助WebAssembly组件模型来自定义Wasm及开发对应的go语言SDK。","keywords":null,"kind":"page","lang":"en","lastmod":1693570279,"objectID":"f62a14869542df7e99eda5a272fb0b82","permalink":"https://taction.top/post/wit-in-go-practice/","publishdate":"2023-09-01T20:11:19+08:00","readingtime":9,"relpermalink":"/post/wit-in-go-practice/","section":"post","summary":"TL;DR 本文以实际案例介绍如何借助WebAssembly组件模型来自定义Wasm及开发对应的go语言SDK。 一 概述 Dapr是一个分布式运行时，那么","tags":["webassembly","wit"],"title":"Wit in Go Practice","type":"post","url":"/post/wit-in-go-practice/","weight":0,"wordcount":4285},{"author":null,"categories":["Tech"],"content":"WebAssembly 组件模型是一个WebAssembly [提案](https://github.com/WebAssembly/proposals)，旨在通过定义模块在应用程序或库中如何组合来构建核心 WebAssembly 标准。简单来说这是一个如何定义组件的标准。WASI现在正在使用Component Model所定义的格式来定义自己的ABI接口。由于这是一个WebAssembly社区关于组件标准的提案，所以它可能更具有生命力，成为一个最终标准。本文就主要介绍它是什么以及在go语言中该如何使用。","date":1692619523,"description":"WebAssembly 组件模型是一个WebAssembly [提案](https://github.com/WebAssembly/proposals)，旨在通过定义模块在应用程序或库中如何组合来构建核心 WebAssembly 标准。简单来说这是一个如何定义组件的标准。WASI现在正在使用Component Model所定义的格式来定义自己的ABI接口。由于这是一个WebAssembly社区关于组件标准的提案，所以它可能更具有生命力，成为一个最终标准。本文就主要介绍它是什么以及在go语言中该如何使用。","dir":"post/","excerpt_html":"WebAssembly 组件模型是一个WebAssembly [提案](https://github.com/WebAssembly/proposals)，旨在通过定义模块在应用程序或库中如何组合来构建核心 WebAssembly 标准。简单来说这是一个如何定义组件的标准。WASI现在正在使用Component Model所定义的格式来定义自己的ABI接口。由于这是一个WebAssembly社区关于组件标准的提案，所以它可能更具有生命力，成为一个最终标准。本文就主要介绍它是什么以及在go语言中该如何使用。","excerpt_text":"WebAssembly 组件模型是一个WebAssembly [提案](https://github.com/WebAssembly/proposals)，旨在通过定义模块在应用程序或库中如何组合来构建核心 WebAssembly 标准。简单来说这是一个如何定义组件的标准。WASI现在正在使用Component Model所定义的格式来定义自己的ABI接口。由于这是一个WebAssembly社区关于组件标准的提案，所以它可能更具有生命力，成为一个最终标准。本文就主要介绍它是什么以及在go语言中该如何使用。","expirydate":-62135596800,"fuzzywordcount":4900,"html":"WebAssembly 组件模型是一个WebAssembly [提案](https://github.com/WebAssembly/proposals)，旨在通过定义模块在应用程序或库中如何组合来构建核心 WebAssembly 标准。简单来说这是一个如何定义组件的标准。WASI现在正在使用Component Model所定义的格式来定义自己的ABI接口。由于这是一个WebAssembly社区关于组件标准的提案，所以它可能更具有生命力，成为一个最终标准。本文就主要介绍它是什么以及在go语言中该如何使用。","keywords":null,"kind":"page","lang":"en","lastmod":1692619523,"objectID":"ba0fe71b187621f3b097a9d2400b5032","permalink":"https://taction.top/post/wit-in-go/","publishdate":"2023-08-21T20:05:23+08:00","readingtime":10,"relpermalink":"/post/wit-in-go/","section":"post","summary":"TL;DR 本文介绍使用WebAssembly Component Model定义的ABI，如何实现其go语言的sdk，包括guest和host的sdk。 基本介绍 WebAssembly 组件模","tags":["webassembly","wit"],"title":"WebAssembly Component Model介绍及如何与go语言结合","type":"post","url":"/post/wit-in-go/","weight":0,"wordcount":4865},{"author":null,"categories":["Tech"],"content":"本文从源码角度分析Dapr Http Wasm的实现原理，以及给出一些常见的使用场景案例。","date":1687703992,"description":"本文从源码角度分析Dapr Http Wasm的实现原理，以及给出一些常见的使用场景案例。","dir":"post/","excerpt_html":"本文从源码角度分析Dapr Http Wasm的实现原理，以及给出一些常见的使用场景案例。","excerpt_text":"本文从源码角度分析Dapr Http Wasm的实现原理，以及给出一些常见的使用场景案例。","expirydate":-62135596800,"fuzzywordcount":4800,"html":"本文从源码角度分析Dapr Http Wasm的实现原理，以及给出一些常见的使用场景案例。","keywords":null,"kind":"page","lang":"en","lastmod":1687703992,"objectID":"3cb162a7cf81ab745db6fe8e21c1c890","permalink":"https://taction.top/2023/06/25/2023-06-25-http-wasm-middleware.md/","publishdate":"2023-06-25T22:39:52+08:00","readingtime":10,"relpermalink":"/2023/06/25/2023-06-25-http-wasm-middleware.md/","section":"post","summary":"本文从源码角度分析Dapr Http Wasm的实现原理，以及给出一些常见的使用场景案例。 Dapr runtime middleware dapr将会在初始化的时候调用一次GetHandler","tags":["dapr"],"title":"Dapr Http Wasm Middleware","type":"post","url":"/2023/06/25/2023-06-25-http-wasm-middleware.md/","weight":0,"wordcount":4708},{"author":null,"categories":["Tech"],"content":"介绍如何在k8s环境中调试dapr sidecar","date":1679054761,"description":"介绍如何在k8s环境中调试dapr sidecar","dir":"post/","excerpt_html":"介绍如何在k8s环境中调试dapr sidecar","excerpt_text":"介绍如何在k8s环境中调试dapr sidecar","expirydate":-62135596800,"fuzzywordcount":1600,"html":"介绍如何在k8s环境中调试dapr sidecar","keywords":null,"kind":"page","lang":"en","lastmod":1679054761,"objectID":"27a9ad9d381bbb98f239297878b595b8","permalink":"https://taction.top/2023/03/17/2023-03-17-debug-dapr-k8s.md/","publishdate":"2023-03-17T20:06:01+08:00","readingtime":4,"relpermalink":"/2023/03/17/2023-03-17-debug-dapr-k8s.md/","section":"post","summary":"准备工作 编译 拉代码构建二进制,这里面最主要的就是DEBUG=1dapr里只要加了这个，构建二进制的时候就会构建附带debugger信息的二进","tags":["dapr"],"title":"Debug Dapr In K8s","type":"post","url":"/2023/03/17/2023-03-17-debug-dapr-k8s.md/","weight":0,"wordcount":1581},{"author":null,"categories":["Tech"],"content":"本文以dapr [Hello Kubernetes](https://github.com/dapr/quickstarts/tree/master/tutorials/hello-kubernetes)教程为基础，将其中state组件替换为pluggable state组件，通过这个过程来介绍pluggable component的使用。","date":1678961524,"description":"本文以dapr [Hello Kubernetes](https://github.com/dapr/quickstarts/tree/master/tutorials/hello-kubernetes)教程为基础，将其中state组件替换为pluggable state组件，通过这个过程来介绍pluggable component的使用。","dir":"post/","excerpt_html":"本文以dapr [Hello Kubernetes](https://github.com/dapr/quickstarts/tree/master/tutorials/hello-kubernetes)教程为基础，将其中state组件替换为pluggable state组件，通过这个过程来介绍pluggable component的使用。","excerpt_text":"本文以dapr [Hello Kubernetes](https://github.com/dapr/quickstarts/tree/master/tutorials/hello-kubernetes)教程为基础，将其中state组件替换为pluggable state组件，通过这个过程来介绍pluggable component的使用。","expirydate":-62135596800,"fuzzywordcount":1200,"html":"本文以dapr [Hello Kubernetes](https://github.com/dapr/quickstarts/tree/master/tutorials/hello-kubernetes)教程为基础，将其中state组件替换为pluggable state组件，通过这个过程来介绍pluggable component的使用。","keywords":null,"kind":"page","lang":"en","lastmod":1678961524,"objectID":"82092e3176ace2242c0c00c35d5eef51","permalink":"https://taction.top/2023/03/16/2023-03-16-deploying-pluggable-k8s.md/","publishdate":"2023-03-16T18:12:04+08:00","readingtime":3,"relpermalink":"/2023/03/16/2023-03-16-deploying-pluggable-k8s.md/","section":"post","summary":"本文以dapr Hello Kubernetes教程为基础，将其中state组件替换为pluggable state组件，通过这个过程来介绍pluggab","tags":["dapr"],"title":"Deploying Dapr Pluggable Component In K8s","type":"post","url":"/2023/03/16/2023-03-16-deploying-pluggable-k8s.md/","weight":0,"wordcount":1194},{"author":null,"categories":["Tech"],"content":"本文主要从dapr运行时、SDK和部署3部分的源码来介绍dapr的Pluggable component","date":1678194578,"description":"本文主要从dapr运行时、SDK和部署3部分的源码来介绍dapr的Pluggable component","dir":"post/","excerpt_html":"本文主要从dapr运行时、SDK和部署3部分的源码来介绍dapr的Pluggable component","excerpt_text":"本文主要从dapr运行时、SDK和部署3部分的源码来介绍dapr的Pluggable component","expirydate":-62135596800,"fuzzywordcount":9200,"html":"本文主要从dapr运行时、SDK和部署3部分的源码来介绍dapr的Pluggable component","keywords":null,"kind":"page","lang":"en","lastmod":1678194578,"objectID":"1a6f6d5913062b1f94ab596a5cbe165e","permalink":"https://taction.top/2023/03/07/2023-03-07-pluggable-component.md/","publishdate":"2023-03-07T21:09:38+08:00","readingtime":19,"relpermalink":"/2023/03/07/2023-03-07-pluggable-component.md/","section":"post","summary":"本文主要从dapr运行时、SDK和部署3部分的源码来介绍dapr的Pluggable component dapr运行时 Pluggable 组件自动发现机制 Dapr在实例化一个组","tags":["dapr"],"title":"Dapr Pluggable component源码分析介绍","type":"post","url":"/2023/03/07/2023-03-07-pluggable-component.md/","weight":0,"wordcount":9196},{"author":null,"categories":["Tech"],"content":"通过之前文章，大概对fermyon平台架构有了了解。我们知道通过`spin up [-f path/to/spin.toml]`命令可以“启动”一个wasm程序，但是在这个过程中实际执行的代码逻辑是什么？我们的网络请求发给了谁，如何传递到wasm程序的？接下来从实际的代码执行角度来看下这个过程中的实际代码逻辑。实际上这里大概分为了两个大步骤，spin up命令对参数进行解析，根据启动时指定的是file（默认）还是bindle来进行不同的数据解析准备，最终通过spin trigger命令来进行实际动作。（从这个角度来看spin up就是为了方便命令行使用的用户友好的封装）","date":1676104060,"description":"通过之前文章，大概对fermyon平台架构有了了解。我们知道通过`spin up [-f path/to/spin.toml]`命令可以“启动”一个wasm程序，但是在这个过程中实际执行的代码逻辑是什么？我们的网络请求发给了谁，如何传递到wasm程序的？接下来从实际的代码执行角度来看下这个过程中的实际代码逻辑。实际上这里大概分为了两个大步骤，spin up命令对参数进行解析，根据启动时指定的是file（默认）还是bindle来进行不同的数据解析准备，最终通过spin trigger命令来进行实际动作。（从这个角度来看spin up就是为了方便命令行使用的用户友好的封装）","dir":"post/","excerpt_html":"通过之前文章，大概对fermyon平台架构有了了解。我们知道通过`spin up [-f path/to/spin.toml]`命令可以“启动”一个wasm程序，但是在这个过程中实际执行的代码逻辑是什么？我们的网络请求发给了谁，如何传递到wasm程序的？接下来从实际的代码执行角度来看下这个过程中的实际代码逻辑。实际上这里大概分为了两个大步骤，spin up命令对参数进行解析，根据启动时指定的是file（默认）还是bindle来进行不同的数据解析准备，最终通过spin trigger命令来进行实际动作。（从这个角度来看spin up就是为了方便命令行使用的用户友好的封装）","excerpt_text":"通过之前文章，大概对fermyon平台架构有了了解。我们知道通过`spin up [-f path/to/spin.toml]`命令可以“启动”一个wasm程序，但是在这个过程中实际执行的代码逻辑是什么？我们的网络请求发给了谁，如何传递到wasm程序的？接下来从实际的代码执行角度来看下这个过程中的实际代码逻辑。实际上这里大概分为了两个大步骤，spin up命令对参数进行解析，根据启动时指定的是file（默认）还是bindle来进行不同的数据解析准备，最终通过spin trigger命令来进行实际动作。（从这个角度来看spin up就是为了方便命令行使用的用户友好的封装）","expirydate":-62135596800,"fuzzywordcount":3500,"html":"通过之前文章，大概对fermyon平台架构有了了解。我们知道通过`spin up [-f path/to/spin.toml]`命令可以“启动”一个wasm程序，但是在这个过程中实际执行的代码逻辑是什么？我们的网络请求发给了谁，如何传递到wasm程序的？接下来从实际的代码执行角度来看下这个过程中的实际代码逻辑。实际上这里大概分为了两个大步骤，spin up命令对参数进行解析，根据启动时指定的是file（默认）还是bindle来进行不同的数据解析准备，最终通过spin trigger命令来进行实际动作。（从这个角度来看spin up就是为了方便命令行使用的用户友好的封装）","keywords":null,"kind":"page","lang":"en","lastmod":1676104060,"objectID":"fbea4d35c6e4c625d75a2aca12239bb0","permalink":"https://taction.top/2023/02/11/2023-02-11-spin-up-sourcecode.md/","publishdate":"2023-02-11T16:27:40+08:00","readingtime":7,"relpermalink":"/2023/02/11/2023-02-11-spin-up-sourcecode.md/","section":"post","summary":"简介 通过之前文章，大概对fermyon平台架构有了了解。我们知道通过spin up [-f path/to/spin.toml]命令可以“启动”一个wa","tags":["spin"],"title":"Spin up 源码分析","type":"post","url":"/2023/02/11/2023-02-11-spin-up-sourcecode.md/","weight":0,"wordcount":3463},{"author":null,"categories":["Tech"],"content":"Spin是一个使用WebAssembly组件构建和运行事件驱动的微服务应用程序的框架。即用于实际执行WebAssembly程序。\n通过[这个案例](https://www.fermyon.com/blog/scale-to-zero-problem?\u0026utm_medium=blog\u0026utm_campaign=related)也能更多看到fermyon的具体架构。简单的画了一下其架构","date":1676103730,"description":"Spin是一个使用WebAssembly组件构建和运行事件驱动的微服务应用程序的框架。即用于实际执行WebAssembly程序。\n通过[这个案例](https://www.fermyon.com/blog/scale-to-zero-problem?\u0026utm_medium=blog\u0026utm_campaign=related)也能更多看到fermyon的具体架构。简单的画了一下其架构","dir":"post/","excerpt_html":"Spin是一个使用WebAssembly组件构建和运行事件驱动的微服务应用程序的框架。即用于实际执行WebAssembly程序。\n通过[这个案例](https://www.fermyon.com/blog/scale-to-zero-problem?\u0026utm_medium=blog\u0026utm_campaign=related)也能更多看到fermyon的具体架构。简单的画了一下其架构","excerpt_text":"Spin是一个使用WebAssembly组件构建和运行事件驱动的微服务应用程序的框架。即用于实际执行WebAssembly程序。\n通过[这个案例](https://www.fermyon.com/blog/scale-to-zero-problem?\u0026utm_medium=blog\u0026utm_campaign=related)也能更多看到fermyon的具体架构。简单的画了一下其架构","expirydate":-62135596800,"fuzzywordcount":2600,"html":"Spin是一个使用WebAssembly组件构建和运行事件驱动的微服务应用程序的框架。即用于实际执行WebAssembly程序。\n通过[这个案例](https://www.fermyon.com/blog/scale-to-zero-problem?\u0026utm_medium=blog\u0026utm_campaign=related)也能更多看到fermyon的具体架构。简单的画了一下其架构","keywords":null,"kind":"page","lang":"en","lastmod":1676103730,"objectID":"d8d21a8cd737b2fffebdfd743b2d07b8","permalink":"https://taction.top/2023/02/11/2023-02-11-spin-introduction.md/","publishdate":"2023-02-11T16:22:10+08:00","readingtime":6,"relpermalink":"/2023/02/11/2023-02-11-spin-introduction.md/","section":"post","summary":"介绍 hippo是一个WebAssembly PaaS平台，用于创建基于WebAssembly的微服务和Web应用程序。它提供了一个基于浏览器的","tags":["spin"],"title":"Spin介绍","type":"post","url":"/2023/02/11/2023-02-11-spin-introduction.md/","weight":0,"wordcount":2566},{"author":null,"categories":["Tech"],"content":"","date":1669633347,"description":"","dir":"post/","excerpt_html":"","excerpt_text":"","expirydate":-62135596800,"fuzzywordcount":3700,"html":"","keywords":null,"kind":"page","lang":"en","lastmod":1669633347,"objectID":"026d3de607ee711d6a568c29e3aba723","permalink":"https://taction.top/2022/11/28/2022-11-28-dockerWasmPreview.md/","publishdate":"2022-11-28T19:02:27+08:00","readingtime":8,"relpermalink":"/2022/11/28/2022-11-28-dockerWasmPreview.md/","section":"post","summary":"背景 docker宣布支持wasm，并且在wasm day上做了演讲。看到这个消息的时候初步跑了一下官方教程，成功的失败了，止步在contain","tags":["webassembly","docker"],"title":"运行docker wasm preview 失败教程","type":"post","url":"/2022/11/28/2022-11-28-dockerWasmPreview.md/","weight":0,"wordcount":3602},{"author":null,"categories":["Tech"],"content":"[Dapr](https://docs.dapr.io/concepts/overview/)是一个可移植的、事件驱动的运行时，它使任何开发人员都能轻松地构建在云和边缘运行的有弹性、无状态和有状态的应用程序，它同时也支持多种编程语言和开发框架。Dapr利用边车架构的优势，帮助解决构建微服务所带来的挑战，并使代码与平台无关。[Wasmcloud](https://wasmcloud.dev/overview/)是一个旨在帮助开发人员快速轻松地编写默认安全业务逻辑的平台，具有快速反馈循环，不受样板文件、integrated（e.g. tangled）dependencies以及与非功能需求的紧密耦合的负担。它是一套工具和库，可用于构建由称为*actor*的可移植业务逻辑单元组成的分布式应用程序。其actor就是WebAssembly应用程序。","date":1669117505,"description":"[Dapr](https://docs.dapr.io/concepts/overview/)是一个可移植的、事件驱动的运行时，它使任何开发人员都能轻松地构建在云和边缘运行的有弹性、无状态和有状态的应用程序，它同时也支持多种编程语言和开发框架。Dapr利用边车架构的优势，帮助解决构建微服务所带来的挑战，并使代码与平台无关。[Wasmcloud](https://wasmcloud.dev/overview/)是一个旨在帮助开发人员快速轻松地编写默认安全业务逻辑的平台，具有快速反馈循环，不受样板文件、integrated（e.g. tangled）dependencies以及与非功能需求的紧密耦合的负担。它是一套工具和库，可用于构建由称为*actor*的可移植业务逻辑单元组成的分布式应用程序。其actor就是WebAssembly应用程序。","dir":"post/","excerpt_html":"[Dapr](https://docs.dapr.io/concepts/overview/)是一个可移植的、事件驱动的运行时，它使任何开发人员都能轻松地构建在云和边缘运行的有弹性、无状态和有状态的应用程序，它同时也支持多种编程语言和开发框架。Dapr利用边车架构的优势，帮助解决构建微服务所带来的挑战，并使代码与平台无关。[Wasmcloud](https://wasmcloud.dev/overview/)是一个旨在帮助开发人员快速轻松地编写默认安全业务逻辑的平台，具有快速反馈循环，不受样板文件、integrated（e.g. tangled）dependencies以及与非功能需求的紧密耦合的负担。它是一套工具和库，可用于构建由称为*actor*的可移植业务逻辑单元组成的分布式应用程序。其actor就是WebAssembly应用程序。","excerpt_text":"[Dapr](https://docs.dapr.io/concepts/overview/)是一个可移植的、事件驱动的运行时，它使任何开发人员都能轻松地构建在云和边缘运行的有弹性、无状态和有状态的应用程序，它同时也支持多种编程语言和开发框架。Dapr利用边车架构的优势，帮助解决构建微服务所带来的挑战，并使代码与平台无关。[Wasmcloud](https://wasmcloud.dev/overview/)是一个旨在帮助开发人员快速轻松地编写默认安全业务逻辑的平台，具有快速反馈循环，不受样板文件、integrated（e.g. tangled）dependencies以及与非功能需求的紧密耦合的负担。它是一套工具和库，可用于构建由称为*actor*的可移植业务逻辑单元组成的分布式应用程序。其actor就是WebAssembly应用程序。","expirydate":-62135596800,"fuzzywordcount":2400,"html":"[Dapr](https://docs.dapr.io/concepts/overview/)是一个可移植的、事件驱动的运行时，它使任何开发人员都能轻松地构建在云和边缘运行的有弹性、无状态和有状态的应用程序，它同时也支持多种编程语言和开发框架。Dapr利用边车架构的优势，帮助解决构建微服务所带来的挑战，并使代码与平台无关。[Wasmcloud](https://wasmcloud.dev/overview/)是一个旨在帮助开发人员快速轻松地编写默认安全业务逻辑的平台，具有快速反馈循环，不受样板文件、integrated（e.g. tangled）dependencies以及与非功能需求的紧密耦合的负担。它是一套工具和库，可用于构建由称为*actor*的可移植业务逻辑单元组成的分布式应用程序。其actor就是WebAssembly应用程序。","keywords":null,"kind":"page","lang":"en","lastmod":1669117505,"objectID":"443e333ce056c7aaecef8cef8e51cc18","permalink":"https://taction.top/2022/11/22/2022-11-22-dapr-provider.md/","publishdate":"2022-11-22T19:45:05+08:00","readingtime":5,"relpermalink":"/2022/11/22/2022-11-22-dapr-provider.md/","section":"post","summary":"Wasmcloud和Dapr基础介绍 Dapr是一个可移植的、事件驱动的运行时，它使任何开发人员都能轻松地构建在云和边缘运行的有弹性、无状态和","tags":["wasmcloud","dapr"],"title":"Dapr Wasmcloud Provider","type":"post","url":"/2022/11/22/2022-11-22-dapr-provider.md/","weight":0,"wordcount":2330},{"author":null,"categories":["Tech"],"content":"在[wasmcloud actor 调用 actor](https://wasmcloud.dev/app-dev/a2a/)的文档中，有介绍如何通过actor调用actor，但是在查看[wasmcloudexamples](https://github.com/wasmCloud/examples)和[interfaces](https://github.com/wasmCloud/interfaces)示例项目的时候均没有看到示例。因此本文档从零开始创建一个actor调用actor的示例。","date":1667721334,"description":"在[wasmcloud actor 调用 actor](https://wasmcloud.dev/app-dev/a2a/)的文档中，有介绍如何通过actor调用actor，但是在查看[wasmcloudexamples](https://github.com/wasmCloud/examples)和[interfaces](https://github.com/wasmCloud/interfaces)示例项目的时候均没有看到示例。因此本文档从零开始创建一个actor调用actor的示例。","dir":"post/","excerpt_html":"在[wasmcloud actor 调用 actor](https://wasmcloud.dev/app-dev/a2a/)的文档中，有介绍如何通过actor调用actor，但是在查看[wasmcloudexamples](https://github.com/wasmCloud/examples)和[interfaces](https://github.com/wasmCloud/interfaces)示例项目的时候均没有看到示例。因此本文档从零开始创建一个actor调用actor的示例。","excerpt_text":"在[wasmcloud actor 调用 actor](https://wasmcloud.dev/app-dev/a2a/)的文档中，有介绍如何通过actor调用actor，但是在查看[wasmcloudexamples](https://github.com/wasmCloud/examples)和[interfaces](https://github.com/wasmCloud/interfaces)示例项目的时候均没有看到示例。因此本文档从零开始创建一个actor调用actor的示例。","expirydate":-62135596800,"fuzzywordcount":2500,"html":"在[wasmcloud actor 调用 actor](https://wasmcloud.dev/app-dev/a2a/)的文档中，有介绍如何通过actor调用actor，但是在查看[wasmcloudexamples](https://github.com/wasmCloud/examples)和[interfaces](https://github.com/wasmCloud/interfaces)示例项目的时候均没有看到示例。因此本文档从零开始创建一个actor调用actor的示例。","keywords":null,"kind":"page","lang":"en","lastmod":1667721334,"objectID":"f3e97596ee13495c94853f3327573295","permalink":"https://taction.top/2022/11/06/2022-11-06-a2acall.md/","publishdate":"2022-11-06T15:55:34+08:00","readingtime":5,"relpermalink":"/2022/11/06/2022-11-06-a2acall.md/","section":"post","summary":"概述 在wasmcloud actor 调用 actor的文档中，有介绍如何通过actor调用actor，但是在查看wasmcloudexamples和in","tags":["wasmcloud"],"title":"Actor to Actor call","type":"post","url":"/2022/11/06/2022-11-06-a2acall.md/","weight":0,"wordcount":2413},{"author":null,"categories":["Tech"],"content":"介绍如何通过Rebase操作补DCO签名","date":1639826854,"description":"介绍如何通过Rebase操作补DCO签名","dir":"post/","excerpt_html":"介绍如何通过Rebase操作补DCO签名","excerpt_text":"介绍如何通过Rebase操作补DCO签名","expirydate":-62135596800,"fuzzywordcount":1200,"html":"介绍如何通过Rebase操作补DCO签名","keywords":null,"kind":"page","lang":"en","lastmod":1639826854,"objectID":"773846df6b255b623b8f37f1a8de7f6d","permalink":"https://taction.top/2021/12/18/2021-12-18-dco-rebase.md/","publishdate":"2021-12-18T19:27:34+08:00","readingtime":3,"relpermalink":"/2021/12/18/2021-12-18-dco-rebase.md/","section":"post","summary":"使用rebase对提交进行签名 背景 提交的一个开源项目增加了DCO要求，而且项目是通过merge来进行代码管理的。所以有些比较久的提交有比较多","tags":["git","dco"],"title":"使用rebase对提交进行DCO签名","type":"post","url":"/2021/12/18/2021-12-18-dco-rebase.md/","weight":0,"wordcount":1100},{"author":null,"categories":["Tech"],"content":"","date":1638866793,"description":"","dir":"post/","excerpt_html":"","excerpt_text":"","expirydate":-62135596800,"fuzzywordcount":6400,"html":"","keywords":null,"kind":"page","lang":"en","lastmod":1638866793,"objectID":"826661ca366ebb1a269d1dc4cb23bb4f","permalink":"https://taction.top/2021/12/07/2021-12-07-knative-kpa-use.md/","publishdate":"2021-12-07T16:46:33+08:00","readingtime":13,"relpermalink":"/2021/12/07/2021-12-07-knative-kpa-use.md/","section":"post","summary":"本文主要介绍kpa如何配置，以及以revision为角度介绍其中的各项配置的作用。 简介 有全局配置和每个revision的配置。如果revis","tags":["platform"],"title":"Knative KPA","type":"post","url":"/2021/12/07/2021-12-07-knative-kpa-use.md/","weight":0,"wordcount":6371},{"author":null,"categories":["Tech"],"content":"经过前面的介绍，可以发现revision资源是整个流程的核心。那么在不对当前deployment部署托管的情况下。修改revision引用指定的deployment，那么在接受可以对deployment进行有限修改的情况下。就可以直接创建一个revision，让deployment自动获得对应的自动扩缩容的能力。从事后来看，通过这种方式，只需要对deployment增加一个revision name的label以及注入代理pod的修改就够了。通过这种修改方式，ksvc、configuration、route资源就可以弃用了。","date":1638345012,"description":"经过前面的介绍，可以发现revision资源是整个流程的核心。那么在不对当前deployment部署托管的情况下。修改revision引用指定的deployment，那么在接受可以对deployment进行有限修改的情况下。就可以直接创建一个revision，让deployment自动获得对应的自动扩缩容的能力。从事后来看，通过这种方式，只需要对deployment增加一个revision name的label以及注入代理pod的修改就够了。通过这种修改方式，ksvc、configuration、route资源就可以弃用了。","dir":"post/","excerpt_html":"经过前面的介绍，可以发现revision资源是整个流程的核心。那么在不对当前deployment部署托管的情况下。修改revision引用指定的deployment，那么在接受可以对deployment进行有限修改的情况下。就可以直接创建一个revision，让deployment自动获得对应的自动扩缩容的能力。从事后来看，通过这种方式，只需要对deployment增加一个revision name的label以及注入代理pod的修改就够了。通过这种修改方式，ksvc、configuration、route资源就可以弃用了。","excerpt_text":"经过前面的介绍，可以发现revision资源是整个流程的核心。那么在不对当前deployment部署托管的情况下。修改revision引用指定的deployment，那么在接受可以对deployment进行有限修改的情况下。就可以直接创建一个revision，让deployment自动获得对应的自动扩缩容的能力。从事后来看，通过这种方式，只需要对deployment增加一个revision name的label以及注入代理pod的修改就够了。通过这种修改方式，ksvc、configuration、route资源就可以弃用了。","expirydate":-62135596800,"fuzzywordcount":1900,"html":"经过前面的介绍，可以发现revision资源是整个流程的核心。那么在不对当前deployment部署托管的情况下。修改revision引用指定的deployment，那么在接受可以对deployment进行有限修改的情况下。就可以直接创建一个revision，让deployment自动获得对应的自动扩缩容的能力。从事后来看，通过这种方式，只需要对deployment增加一个revision name的label以及注入代理pod的修改就够了。通过这种修改方式，ksvc、configuration、route资源就可以弃用了。","keywords":null,"kind":"page","lang":"en","lastmod":1638345012,"objectID":"cb10ee1137a40039467b000486074b0a","permalink":"https://taction.top/2021/12/01/2021-12-01-knative-demo.md/","publishdate":"2021-12-01T15:50:12+08:00","readingtime":4,"relpermalink":"/2021/12/01/2021-12-01-knative-demo.md/","section":"post","summary":"概述 经过前面的介绍，可以发现revision资源是整个流程的核心。那么在不对当前deployment部署托管的情况下。修改revision引","tags":["Knative"],"title":"Knative自定义流程Demo","type":"post","url":"/2021/12/01/2021-12-01-knative-demo.md/","weight":0,"wordcount":1874},{"author":null,"categories":["Tech"],"content":"queue是knative在每个deployment都会为业务容器注入的\"sidecar\"，负责其入口流量代理行为。并且会对请求进行计数，对外暴露metrice接口，autoscaler会定期拉取这些指标数据。","date":1638344787,"description":"queue是knative在每个deployment都会为业务容器注入的\"sidecar\"，负责其入口流量代理行为。并且会对请求进行计数，对外暴露metrice接口，autoscaler会定期拉取这些指标数据。","dir":"post/","excerpt_html":"queue是knative在每个deployment都会为业务容器注入的\"sidecar\"，负责其入口流量代理行为。并且会对请求进行计数，对外暴露metrice接口，autoscaler会定期拉取这些指标数据。","excerpt_text":"queue是knative在每个deployment都会为业务容器注入的\"sidecar\"，负责其入口流量代理行为。并且会对请求进行计数，对外暴露metrice接口，autoscaler会定期拉取这些指标数据。","expirydate":-62135596800,"fuzzywordcount":1500,"html":"queue是knative在每个deployment都会为业务容器注入的\"sidecar\"，负责其入口流量代理行为。并且会对请求进行计数，对外暴露metrice接口，autoscaler会定期拉取这些指标数据。","keywords":null,"kind":"page","lang":"en","lastmod":1638344787,"objectID":"a84a478f9418c0f907a13fcabbc730d8","permalink":"https://taction.top/2021/12/01/2021-12-01-knative-queue.md/","publishdate":"2021-12-01T15:46:27+08:00","readingtime":3,"relpermalink":"/2021/12/01/2021-12-01-knative-queue.md/","section":"post","summary":"简介 queue是knative在每个deployment都会为业务容器注入的\u0026quot;sidecar\u0026quot;，负责其入口流量代理行为。","tags":["Knative"],"title":"Knative Queue","type":"post","url":"/2021/12/01/2021-12-01-knative-queue.md/","weight":0,"wordcount":1423},{"author":null,"categories":["Tech"],"content":"","date":1638344650,"description":"","dir":"post/","excerpt_html":"","excerpt_text":"","expirydate":-62135596800,"fuzzywordcount":12400,"html":"","keywords":null,"kind":"page","lang":"en","lastmod":1638344650,"objectID":"121299fd868fff24b34eaca5ca2991cb","permalink":"https://taction.top/2021/12/01/2021-12-01-knative-scalefrom0.md/","publishdate":"2021-12-01T15:44:10+08:00","readingtime":25,"relpermalink":"/2021/12/01/2021-12-01-knative-scalefrom0.md/","section":"post","summary":"本文主要从源码分析角度来看从0开始扩容和缩容到0的过程。主要核心点在于从0开始扩容，主要涉及activator和autoscaler组件。在","tags":["Knative"],"title":"Knative","type":"post","url":"/2021/12/01/2021-12-01-knative-scalefrom0.md/","weight":0,"wordcount":12369},{"author":null,"categories":["Tech"],"content":"本文主要介绍knative中的CRD，及以一个CRD为例介绍，只创建了ksvc其他所有的衍生CRD是如何被创建的。最后以一个实际运行的knative service为例展示了各个实际CRD的案例内容。","date":1638344602,"description":"本文主要介绍knative中的CRD，及以一个CRD为例介绍，只创建了ksvc其他所有的衍生CRD是如何被创建的。最后以一个实际运行的knative service为例展示了各个实际CRD的案例内容。","dir":"post/","excerpt_html":"本文主要介绍knative中的CRD，及以一个CRD为例介绍，只创建了ksvc其他所有的衍生CRD是如何被创建的。最后以一个实际运行的knative service为例展示了各个实际CRD的案例内容。","excerpt_text":"本文主要介绍knative中的CRD，及以一个CRD为例介绍，只创建了ksvc其他所有的衍生CRD是如何被创建的。最后以一个实际运行的knative service为例展示了各个实际CRD的案例内容。","expirydate":-62135596800,"fuzzywordcount":4100,"html":"本文主要介绍knative中的CRD，及以一个CRD为例介绍，只创建了ksvc其他所有的衍生CRD是如何被创建的。最后以一个实际运行的knative service为例展示了各个实际CRD的案例内容。","keywords":null,"kind":"page","lang":"en","lastmod":1638344602,"objectID":"0da2820958f609cff7352c17562963f6","permalink":"https://taction.top/2021/12/01/2021-12-01-knative-crd.md/","publishdate":"2021-12-01T15:43:22+08:00","readingtime":9,"relpermalink":"/2021/12/01/2021-12-01-knative-crd.md/","section":"post","summary":"TL；DR 本文主要介绍knative中的CRD，及以一个CRD为例介绍，只创建了ksvc其他所有的衍生CRD是如何被创建的。最后以一个实际运","tags":["Knative"],"title":"Knative CRD","type":"post","url":"/2021/12/01/2021-12-01-knative-crd.md/","weight":0,"wordcount":4036},{"author":null,"categories":["Tech"],"content":"","date":1637395096,"description":"","dir":"post/","excerpt_html":"","excerpt_text":"","expirydate":-62135596800,"fuzzywordcount":2200,"html":"","keywords":null,"kind":"page","lang":"en","lastmod":1637395096,"objectID":"fb868cbc8ee9a101cabf63fc85058c07","permalink":"https://taction.top/2021/11/20/2021-11-20-acpuquestion.md/","publishdate":"2021-11-20T15:58:16+08:00","readingtime":5,"relpermalink":"/2021/11/20/2021-11-20-acpuquestion.md/","section":"post","summary":"问题描述 公司采用了自研的sidecar，是用go语言实现的，在部署的时候限制了sidecar的CPU占用为0.5核。且在sidecar中实现","tags":["go"],"title":"一次关于sidecar的问题排查","type":"post","url":"/2021/11/20/2021-11-20-acpuquestion.md/","weight":0,"wordcount":2120},{"author":null,"categories":["Tech"],"content":"本文主要介绍在本机IED中如何远程调试位于k8s中的knative程序。","date":1636011410,"description":"本文主要介绍在本机IED中如何远程调试位于k8s中的knative程序。","dir":"post/","excerpt_html":"本文主要介绍在本机IED中如何远程调试位于k8s中的knative程序。","excerpt_text":"本文主要介绍在本机IED中如何远程调试位于k8s中的knative程序。","expirydate":-62135596800,"fuzzywordcount":1900,"html":"本文主要介绍在本机IED中如何远程调试位于k8s中的knative程序。","keywords":null,"kind":"page","lang":"en","lastmod":1636011410,"objectID":"8d4c71945ee0432d4158370528a1faf7","permalink":"https://taction.top/2021/11/04/2021-11-04-debug-knative.md/","publishdate":"2021-11-04T15:36:50+08:00","readingtime":4,"relpermalink":"/2021/11/04/2021-11-04-debug-knative.md/","section":"post","summary":"TL;DR 本文主要介绍在本机IED中如何远程调试位于k8s中的knative程序。 目标 由于knative组件运行在k8s中，当发生错误的时候，在对代","tags":["Knative"],"title":"Debug Knative","type":"post","url":"/2021/11/04/2021-11-04-debug-knative.md/","weight":0,"wordcount":1890},{"author":null,"categories":["Tech"],"content":"本文档主要介绍跟随[官网入门教程](https://knative.dev/docs/getting-started/)和[minikube案例](https://github.com/csantanapr/knative-minikube)运行knative的hello world。中间部分命令根据国内众所周知的网络特点做了一下适配。本篇基本未涉及原理性介绍。","date":1635745280,"description":"本文档主要介绍跟随[官网入门教程](https://knative.dev/docs/getting-started/)和[minikube案例](https://github.com/csantanapr/knative-minikube)运行knative的hello world。中间部分命令根据国内众所周知的网络特点做了一下适配。本篇基本未涉及原理性介绍。","dir":"post/","excerpt_html":"本文档主要介绍跟随[官网入门教程](https://knative.dev/docs/getting-started/)和[minikube案例](https://github.com/csantanapr/knative-minikube)运行knative的hello world。中间部分命令根据国内众所周知的网络特点做了一下适配。本篇基本未涉及原理性介绍。","excerpt_text":"本文档主要介绍跟随[官网入门教程](https://knative.dev/docs/getting-started/)和[minikube案例](https://github.com/csantanapr/knative-minikube)运行knative的hello world。中间部分命令根据国内众所周知的网络特点做了一下适配。本篇基本未涉及原理性介绍。","expirydate":-62135596800,"fuzzywordcount":2800,"html":"本文档主要介绍跟随[官网入门教程](https://knative.dev/docs/getting-started/)和[minikube案例](https://github.com/csantanapr/knative-minikube)运行knative的hello world。中间部分命令根据国内众所周知的网络特点做了一下适配。本篇基本未涉及原理性介绍。","keywords":null,"kind":"page","lang":"en","lastmod":1635745280,"objectID":"a6627757d58a4d3c92e9d026a1020e0a","permalink":"https://taction.top/2021/11/01/2021-11-01-knative-use.md/","publishdate":"2021-11-01T13:41:20+08:00","readingtime":6,"relpermalink":"/2021/11/01/2021-11-01-knative-use.md/","section":"post","summary":"本文档主要介绍跟随官网入门教程和minikube案例运行knative的hello world。中间部分命令根据国内众所周知的网络特点做了一下","tags":["Knative"],"title":"Knative Use","type":"post","url":"/2021/11/01/2021-11-01-knative-use.md/","weight":0,"wordcount":2728},{"author":null,"categories":["Tech"],"content":"开发人员可以利用DockerHub和CRI-O等Docker工具部署、管理和运行轻量级WebAssembly应用，这些应用使用[WasmEdge](https://github.com/WasmEdge/WasmEdge)运行时。虽然 WebAssembly 应用可以由多种编程语言编写，但 Rust 是迄今为止最安全、最快的 选择。","date":1635236370,"description":"开发人员可以利用DockerHub和CRI-O等Docker工具部署、管理和运行轻量级WebAssembly应用，这些应用使用[WasmEdge](https://github.com/WasmEdge/WasmEdge)运行时。虽然 WebAssembly 应用可以由多种编程语言编写，但 Rust 是迄今为止最安全、最快的 选择。","dir":"post/","excerpt_html":"开发人员可以利用DockerHub和CRI-O等Docker工具部署、管理和运行轻量级WebAssembly应用，这些应用使用[WasmEdge](https://github.com/WasmEdge/WasmEdge)运行时。虽然 WebAssembly 应用可以由多种编程语言编写，但 Rust 是迄今为止最安全、最快的 选择。","excerpt_text":"开发人员可以利用DockerHub和CRI-O等Docker工具部署、管理和运行轻量级WebAssembly应用，这些应用使用[WasmEdge](https://github.com/WasmEdge/WasmEdge)运行时。虽然 WebAssembly 应用可以由多种编程语言编写，但 Rust 是迄今为止最安全、最快的 选择。","expirydate":-62135596800,"fuzzywordcount":3e3,"html":"开发人员可以利用DockerHub和CRI-O等Docker工具部署、管理和运行轻量级WebAssembly应用，这些应用使用[WasmEdge](https://github.com/WasmEdge/WasmEdge)运行时。虽然 WebAssembly 应用可以由多种编程语言编写，但 Rust 是迄今为止最安全、最快的 选择。","keywords":null,"kind":"page","lang":"en","lastmod":1635236370,"objectID":"fe49b303a97a6e65dcdd148a49e7e23e","permalink":"https://taction.top/2021/10/26/2021-10-26-manage-wasm-using-docker.md/","publishdate":"2021-10-26T16:19:30+08:00","readingtime":6,"relpermalink":"/2021/10/26/2021-10-26-manage-wasm-using-docker.md/","section":"post","summary":"开发人员可以利用DockerHub和CRI-O等Docker工具部署、管理和运行轻量级WebAssembly应用，这些应用使用WasmEdg","tags":["webassembly"],"title":"使用Docker工具在WasmEdge中管理WebAssembly应用程序","type":"post","url":"/2021/10/26/2021-10-26-manage-wasm-using-docker.md/","weight":0,"wordcount":2935},{"author":null,"categories":["Tech"],"content":"WebAssembly 是一种低层次的二进制格式代码，体积小，因此加载和执行速度快。你不需要直接编写 WebAssembly 代码，而是可以从其他高级语言编译而来。**它是一种可移植且通用的二进制指令格式，用于在虚拟机中进行内存安全、沙盒执行。**可以用 C、C++、Rust、AssemblyScript、C#、Go、Swift 等多种语言编写程序，并将它们编译为 Wasm。","date":1634458580,"description":"WebAssembly 是一种低层次的二进制格式代码，体积小，因此加载和执行速度快。你不需要直接编写 WebAssembly 代码，而是可以从其他高级语言编译而来。**它是一种可移植且通用的二进制指令格式，用于在虚拟机中进行内存安全、沙盒执行。**可以用 C、C++、Rust、AssemblyScript、C#、Go、Swift 等多种语言编写程序，并将它们编译为 Wasm。","dir":"post/","excerpt_html":"WebAssembly 是一种低层次的二进制格式代码，体积小，因此加载和执行速度快。你不需要直接编写 WebAssembly 代码，而是可以从其他高级语言编译而来。**它是一种可移植且通用的二进制指令格式，用于在虚拟机中进行内存安全、沙盒执行。**可以用 C、C++、Rust、AssemblyScript、C#、Go、Swift 等多种语言编写程序，并将它们编译为 Wasm。","excerpt_text":"WebAssembly 是一种低层次的二进制格式代码，体积小，因此加载和执行速度快。你不需要直接编写 WebAssembly 代码，而是可以从其他高级语言编译而来。**它是一种可移植且通用的二进制指令格式，用于在虚拟机中进行内存安全、沙盒执行。**可以用 C、C++、Rust、AssemblyScript、C#、Go、Swift 等多种语言编写程序，并将它们编译为 Wasm。","expirydate":-62135596800,"fuzzywordcount":3300,"html":"WebAssembly 是一种低层次的二进制格式代码，体积小，因此加载和执行速度快。你不需要直接编写 WebAssembly 代码，而是可以从其他高级语言编译而来。**它是一种可移植且通用的二进制指令格式，用于在虚拟机中进行内存安全、沙盒执行。**可以用 C、C++、Rust、AssemblyScript、C#、Go、Swift 等多种语言编写程序，并将它们编译为 Wasm。","keywords":null,"kind":"page","lang":"en","lastmod":1634458580,"objectID":"e60d0bc85778d9a8202a8722018158fc","permalink":"https://taction.top/2021/10/17/2021-10-17-wasm1.md/","publishdate":"2021-10-17T16:16:20+08:00","readingtime":7,"relpermalink":"/2021/10/17/2021-10-17-wasm1.md/","section":"post","summary":"一、介绍 1.1 什么是 WebAssembly 运行在沙盒中的二进制格式代码 WebAssembly 是一种低层次的二进制格式代码，体积小，因此加载和执行速度快。你不需要直接编写 WebAssembly 代码，而是可以","tags":["webassembly"],"title":"基于WebAsssembly的Serverless探索1:wasm概述","type":"post","url":"/2021/10/17/2021-10-17-wasm1.md/","weight":0,"wordcount":3215},{"author":null,"categories":["Tech"],"content":"介绍一些在webassembly领域的项目探索","date":1634360341,"description":"介绍一些在webassembly领域的项目探索","dir":"post/","excerpt_html":"介绍一些在webassembly领域的项目探索","excerpt_text":"介绍一些在webassembly领域的项目探索","expirydate":-62135596800,"fuzzywordcount":3e3,"html":"介绍一些在webassembly领域的项目探索","keywords":null,"kind":"page","lang":"en","lastmod":1634360341,"objectID":"7d487edddc2e4d6eb6edf1a26dcfa4f0","permalink":"https://taction.top/2021/10/16/2021-10-16-wasm2.md/","publishdate":"2021-10-16T12:59:01+08:00","readingtime":6,"relpermalink":"/2021/10/16/2021-10-16-wasm2.md/","section":"post","summary":"背景 云原生正在成为新的基础设施 云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生向下封装资源","tags":["webassembly"],"title":"基于WebAsssembly的Serverless探索2：相关项目分析","type":"post","url":"/2021/10/16/2021-10-16-wasm2.md/","weight":0,"wordcount":2991},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"about/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":600,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://taction.top/about/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/about/","section":"","summary":"About Me Huabing Zhao is a software architect, an Istio Member and an ONAP PTL. He has a solid experience in the information and telecommunication technology industry for more than 17 years. Throughout his career, he has built a number of large-scale, cross-country software systems, most of them are still running in production. He loves open source and has been contributing to various open source projects, he is a member","tags":null,"title":"","type":"page","url":"/about/","weight":0,"wordcount":500},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"notes/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1ede8046f9c3a02d422dea7bbf324e64","permalink":"https://taction.top/notes/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/notes/","section":"","summary":"Go 语言学习笔记 Envoy 学习笔记","tags":null,"title":"","type":"page","url":"/notes/","weight":0,"wordcount":12},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"search/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8946788897930c0c0c39fbfcd30ff2e4","permalink":"https://taction.top/search/placeholder/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/search/placeholder/","section":"search","summary":"","tags":null,"title":"","type":"search","url":"/search/placeholder/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":"Archive of historical posts.","date":-62135596800,"description":"Archive of historical posts.","dir":"archive/","excerpt_html":"Archive of historical posts.","excerpt_text":"Archive of historical posts.","expirydate":-62135596800,"fuzzywordcount":100,"html":"Archive of historical posts.","keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a06e5ce9eca4c3260843078104889780","permalink":"https://taction.top/archive/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/archive/","section":"","summary":"","tags":null,"title":"Posts Archive","type":"archive","url":"/archive/","weight":0,"wordcount":0}]